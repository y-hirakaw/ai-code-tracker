{
  "id": "cf9e232f",
  "timestamp": "2025-07-30T16:43:28.69284+09:00",
  "author": "human",
  "files": {
    "cmd/aict/main.go": {
      "path": "cmd/aict/main.go",
      "lines": [
        "package main",
        "",
        "import (",
        "\t\"bufio\"",
        "\t\"encoding/json\"",
        "\t\"flag\"",
        "\t\"fmt\"",
        "\t\"os\"",
        "\t\"os/exec\"",
        "\t\"path/filepath\"",
        "\t\"strings\"",
        "\t\"time\"",
        "",
        "\t\"github.com/y-hirakawa/ai-code-tracker/internal/git\"",
        "\t\"github.com/y-hirakawa/ai-code-tracker/internal/storage\"",
        "\t\"github.com/y-hirakawa/ai-code-tracker/internal/templates\"",
        "\t\"github.com/y-hirakawa/ai-code-tracker/internal/tracker\"",
        ")",
        "",
        "const (",
        "\tdefaultBaseDir = \".ai_code_tracking\"",
        ")",
        "",
        "func main() {",
        "\tif len(os.Args) \u003c 2 {",
        "\t\tprintUsage()",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\tcommand := os.Args[1]",
        "\tswitch command {",
        "\tcase \"init\":",
        "\t\thandleInit()",
        "\tcase \"track\":",
        "\t\thandleTrack()",
        "\tcase \"report\":",
        "\t\thandleReport()",
        "\tcase \"setup-hooks\":",
        "\t\thandleSetupHooks()",
        "\tcase \"reset\":",
        "\t\tif err := handleReset(); err != nil {",
        "\t\t\tfmt.Printf(\"Error: %v\\n\", err)",
        "\t\t\tos.Exit(1)",
        "\t\t}",
        "\tdefault:",
        "\t\tfmt.Printf(\"Unknown command: %s\\n\", command)",
        "\t\tprintUsage()",
        "\t\tos.Exit(1)",
        "\t}",
        "}",
        "",
        "func handleInit() {",
        "\tbaseDir := defaultBaseDir",
        "\t",
        "\tif err := os.MkdirAll(baseDir, 0755); err != nil {",
        "\t\tfmt.Printf(\"Error creating tracking directory: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\tmetricsStorage := storage.NewMetricsStorage(baseDir)",
        "\tconfig := \u0026tracker.Config{",
        "\t\tTargetAIPercentage: 80.0,",
        "\t\tTrackedExtensions:  []string{\".go\", \".py\", \".js\", \".ts\", \".java\", \".cpp\", \".c\", \".h\", \".rs\"},",
        "\t\tExcludePatterns:    []string{\"*_test.go\", \"*.test.js\", \"*.spec.ts\", \"*_generated.go\"},",
        "\t\tAuthorMappings:     make(map[string]string),",
        "\t}",
        "",
        "\tif err := metricsStorage.SaveConfig(config); err != nil {",
        "\t\tfmt.Printf(\"Error saving config: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\tgitAnalyzer := git.NewDiffAnalyzer()",
        "\tif gitAnalyzer.IsGitRepository() {",
        "\t\tuserName := getGitUserName()",
        "\t\tif userName != \"\" {",
        "\t\t\tconfig.AuthorMappings[userName] = \"human\"",
        "\t\t\tmetricsStorage.SaveConfig(config)",
        "\t\t}",
        "\t}",
        "",
        "\t// Create hook scripts only",
        "\tif err := createHookFiles(baseDir); err != nil {",
        "\t\tfmt.Printf(\"Warning: Could not create hook files: %v\\n\", err)",
        "\t} else {",
        "\t\tfmt.Println(\"✓ Hook scripts created in .ai_code_tracking/hooks/\")",
        "\t}",
        "",
        "\tfmt.Println(\"AI Code Tracker initialized successfully!\")",
        "\tfmt.Printf(\"Configuration saved to %s/config.json\\n\", baseDir)",
        "\tfmt.Println(\"Run 'aict setup-hooks' to enable automatic tracking with Claude Code and Git.\")",
        "}",
        "",
        "func handleTrack() {",
        "\tfs := flag.NewFlagSet(\"track\", flag.ExitOnError)",
        "\tauthor := fs.String(\"author\", \"\", \"Author of the checkpoint (required)\")",
        "\tfs.Parse(os.Args[2:])",
        "",
        "\tif *author == \"\" {",
        "\t\tfmt.Println(\"Error: -author flag is required\")",
        "\t\tfmt.Println(\"Usage: aict track -author \u003cauthor_name\u003e\")",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\tbaseDir := defaultBaseDir",
        "\tmetricsStorage := storage.NewMetricsStorage(baseDir)",
        "\t",
        "\tconfig, err := metricsStorage.LoadConfig()",
        "\tif err != nil {",
        "\t\tfmt.Printf(\"Error loading config: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\tcheckpointMgr := tracker.NewCheckpointManager(baseDir)",
        "\tcheckpoint, err := checkpointMgr.CreateCheckpoint(*author, config.TrackedExtensions)",
        "\tif err != nil {",
        "\t\tfmt.Printf(\"Error creating checkpoint: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\tif err := checkpointMgr.SaveCheckpoint(checkpoint); err != nil {",
        "\t\tfmt.Printf(\"Error saving checkpoint: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\t// Load current metrics",
        "\tcurrentMetrics, err := metricsStorage.LoadMetrics()",
        "\tif err != nil {",
        "\t\tfmt.Printf(\"Error loading metrics: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\t// Get all checkpoints to find the previous one",
        "\tallCheckpoints, err := checkpointMgr.GetLatestCheckpoints(\"*\", 100)",
        "\tif err != nil {",
        "\t\tfmt.Printf(\"Error getting checkpoints: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\t// Find the last checkpoint before this one",
        "\tvar previousCheckpoint *tracker.Checkpoint",
        "\tfor i := len(allCheckpoints) - 1; i \u003e= 0; i-- {",
        "\t\tif allCheckpoints[i].ID != checkpoint.ID {",
        "\t\t\tpreviousCheckpoint = allCheckpoints[i]",
        "\t\t\tbreak",
        "\t\t}",
        "\t}",
        "",
        "\tif previousCheckpoint == nil {",
        "\t\t// First checkpoint - all lines are from this author",
        "\t\tif analyzer := tracker.NewAnalyzer(config); analyzer.IsAIAuthor(*author) {",
        "\t\t\tcurrentMetrics.AILines = countTotalLines(checkpoint)",
        "\t\t\tcurrentMetrics.TotalLines = currentMetrics.AILines",
        "\t\t} else {",
        "\t\t\tcurrentMetrics.HumanLines = countTotalLines(checkpoint)",
        "\t\t\tcurrentMetrics.TotalLines = currentMetrics.HumanLines",
        "\t\t}",
        "\t\tcurrentMetrics.LastUpdated = checkpoint.Timestamp",
        "\t} else {",
        "\t\t// Analyze diff between previous and current checkpoint",
        "\t\tanalyzer := tracker.NewAnalyzer(config)",
        "\t\tresult, err := analyzer.AnalyzeCheckpoints(previousCheckpoint, checkpoint)",
        "\t\tif err != nil {",
        "\t\t\tfmt.Printf(\"Error analyzing checkpoints: %v\\n\", err)",
        "\t\t\tos.Exit(1)",
        "\t\t}",
        "",
        "\t\t// Add to current metrics",
        "\t\tcurrentMetrics.AILines += result.AILines",
        "\t\tcurrentMetrics.HumanLines += result.HumanLines",
        "\t\t// Recalculate total lines from the latest checkpoint",
        "\t\tcurrentMetrics.TotalLines = countTotalLines(checkpoint)",
        "\t\t// Ensure human lines = total - AI lines",
        "\t\tcurrentMetrics.HumanLines = currentMetrics.TotalLines - currentMetrics.AILines",
        "\t\tcurrentMetrics.LastUpdated = result.LastUpdated",
        "\t}",
        "",
        "\tif currentMetrics.TotalLines \u003e 0 {",
        "\t\tcurrentMetrics.Percentage = float64(currentMetrics.AILines) / float64(currentMetrics.TotalLines) * 100",
        "\t}",
        "",
        "\tif err := metricsStorage.SaveMetrics(currentMetrics); err != nil {",
        "\t\tfmt.Printf(\"Error saving metrics: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\tfmt.Println(\"Checkpoint saved and metrics updated!\")",
        "\tanalyzer := tracker.NewAnalyzer(config)",
        "\tfmt.Println(analyzer.GenerateReport(currentMetrics))",
        "}",
        "",
        "func handleReport() {",
        "\tbaseDir := defaultBaseDir",
        "\tmetricsStorage := storage.NewMetricsStorage(baseDir)",
        "\t",
        "\tconfig, err := metricsStorage.LoadConfig()",
        "\tif err != nil {",
        "\t\tfmt.Printf(\"Error loading config: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\tmetrics, err := metricsStorage.LoadMetrics()",
        "\tif err != nil {",
        "\t\tfmt.Printf(\"Error loading metrics: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\tanalyzer := tracker.NewAnalyzer(config)",
        "\tfmt.Println(analyzer.GenerateReport(metrics))",
        "}",
        "",
        "func countTotalLines(checkpoint *tracker.Checkpoint) int {",
        "\ttotal := 0",
        "\tfor _, file := range checkpoint.Files {",
        "\t\ttotal += len(file.Lines)",
        "\t}",
        "\treturn total",
        "}",
        "",
        "func handleSetupHooks() {",
        "\tfmt.Println(\"Setting up AI Code Tracker hooks...\")",
        "\t",
        "\t// Setup Git post-commit hook",
        "\tif err := setupGitHook(); err != nil {",
        "\t\tfmt.Printf(\"Error setting up Git post-commit hook: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "\t",
        "\t// Setup Claude Code hooks",
        "\tif err := setupClaudeHooks(); err != nil {",
        "\t\tfmt.Printf(\"Error setting up Claude Code hooks: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "\t",
        "\tfmt.Println()",
        "\tfmt.Println(\"✓ Hook setup complete! Claude Code will now automatically track AI vs Human contributions.\")",
        "}",
        "",
        "func createHookFiles(baseDir string) error {",
        "\thooksDir := filepath.Join(baseDir, \"hooks\")",
        "\tif err := os.MkdirAll(hooksDir, 0755); err != nil {",
        "\t\treturn err",
        "\t}",
        "",
        "\t// Create PreToolUse hook",
        "\tpreHookPath := filepath.Join(hooksDir, \"pre-tool-use.sh\")",
        "\tif err := os.WriteFile(preHookPath, []byte(templates.PreToolUseHook), 0755); err != nil {",
        "\t\treturn err",
        "\t}",
        "",
        "\t// Create PostToolUse hook",
        "\tpostHookPath := filepath.Join(hooksDir, \"post-tool-use.sh\")",
        "\tif err := os.WriteFile(postHookPath, []byte(templates.PostToolUseHook), 0755); err != nil {",
        "\t\treturn err",
        "\t}",
        "",
        "\t// Create Post-commit hook",
        "\tcommitHookPath := filepath.Join(hooksDir, \"post-commit\")",
        "\tif err := os.WriteFile(commitHookPath, []byte(templates.PostCommitHook), 0755); err != nil {",
        "\t\treturn err",
        "\t}",
        "",
        "\treturn nil",
        "}",
        "",
        "func setupGitHook() error {",
        "\t// Copy Git post-commit hook from .ai_code_tracking/hooks/",
        "\thookSource := filepath.Join(defaultBaseDir, \"hooks\", \"post-commit\")",
        "\thookDest := \".git/hooks/post-commit\"",
        "\t",
        "\t// Check if Git post-commit hook already exists",
        "\tif _, err := os.Stat(hookDest); err == nil {",
        "\t\tfmt.Printf(\"Warning: Git post-commit hook already exists at %s\\n\", hookDest)",
        "\t\tfmt.Print(\"Do you want to merge AI Code Tracker functionality? (y/N): \")",
        "\t\t",
        "\t\treader := bufio.NewReader(os.Stdin)",
        "\t\tresponse, _ := reader.ReadString('\\n')",
        "\t\tresponse = strings.TrimSpace(strings.ToLower(response))",
        "\t\t",
        "\t\tif response != \"y\" \u0026\u0026 response != \"yes\" {",
        "\t\t\tfmt.Println(\"Git hook setup cancelled. Please manually integrate the AI Code Tracker hook.\")",
        "\t\t\treturn fmt.Errorf(\"user cancelled Git hook setup\")",
        "\t\t}",
        "\t\t",
        "\t\t// Merge with existing hook",
        "\t\tif err := mergeGitHook(hookSource, hookDest); err != nil {",
        "\t\t\treturn err",
        "\t\t}",
        "\t\tfmt.Println(\"✓ Git post-commit hook merged with existing hook\")",
        "\t} else {",
        "\t\t// No existing hook, just copy",
        "\t\tif err := copyFile(hookSource, hookDest); err != nil {",
        "\t\t\tfmt.Println(\"Make sure to run 'aict init' first to create hook files.\")",
        "\t\t\treturn err",
        "\t\t}",
        "\t\tfmt.Println(\"✓ Git post-commit hook installed\")",
        "\t}",
        "\t",
        "\t// Make it executable",
        "\tif err := os.Chmod(hookDest, 0755); err != nil {",
        "\t\tfmt.Printf(\"Warning: Could not make post-commit hook executable: %v\\n\", err)",
        "\t}",
        "\t",
        "\treturn nil",
        "}",
        "",
        "func setupClaudeHooks() error {",
        "\tclaudeDir := \".claude\"",
        "\tsettingsPath := filepath.Join(claudeDir, \"settings.json\")",
        "\t",
        "\t// Check if Claude settings already exist",
        "\tif _, err := os.Stat(settingsPath); err == nil {",
        "\t\tfmt.Printf(\"Warning: Claude settings already exist at %s\\n\", settingsPath)",
        "\t\tfmt.Print(\"Do you want to merge AI Code Tracker hooks? (y/N): \")",
        "\t\t",
        "\t\treader := bufio.NewReader(os.Stdin)",
        "\t\tresponse, _ := reader.ReadString('\\n')",
        "\t\tresponse = strings.TrimSpace(strings.ToLower(response))",
        "\t\t",
        "\t\tif response != \"y\" \u0026\u0026 response != \"yes\" {",
        "\t\t\tfmt.Println(\"Claude hook setup cancelled. Please manually add the following hooks:\")",
        "\t\t\tfmt.Println(templates.ClaudeSettingsJSON)",
        "\t\t\treturn nil",
        "\t\t}",
        "\t\t",
        "\t\t// Merge with existing settings",
        "\t\tif err := mergeClaudeSettings(settingsPath); err != nil {",
        "\t\t\treturn err",
        "\t\t}",
        "\t\tfmt.Println(\"✓ Claude Code hooks merged with existing settings\")",
        "\t} else {",
        "\t\t// No existing settings, create new",
        "\t\tif err := os.MkdirAll(claudeDir, 0755); err != nil {",
        "\t\t\treturn err",
        "\t\t}",
        "\t\t",
        "\t\tif err := os.WriteFile(settingsPath, []byte(templates.ClaudeSettingsJSON), 0644); err != nil {",
        "\t\t\treturn err",
        "\t\t}",
        "\t\tfmt.Println(\"✓ Claude Code hook configuration created\")",
        "\t}",
        "\t",
        "\tfmt.Println(\"✓ Hook scripts are available in .ai_code_tracking/hooks/\")",
        "\treturn nil",
        "}",
        "",
        "func mergeGitHook(hookSource, hookDest string) error {",
        "\t// Read existing hook",
        "\texistingContent, err := os.ReadFile(hookDest)",
        "\tif err != nil {",
        "\t\treturn err",
        "\t}",
        "\t",
        "\t// Read AI Code Tracker hook",
        "\taictContent, err := os.ReadFile(hookSource)",
        "\tif err != nil {",
        "\t\treturn err",
        "\t}",
        "\t",
        "\t// Create merged content",
        "\tmergedContent := string(existingContent) + \"\\n\\n# AI Code Tracker\\n\" + string(aictContent)",
        "\t",
        "\t// Write merged hook",
        "\treturn os.WriteFile(hookDest, []byte(mergedContent), 0755)",
        "}",
        "",
        "func mergeClaudeSettings(settingsPath string) error {",
        "\t// Read existing settings",
        "\texistingContent, err := os.ReadFile(settingsPath)",
        "\tif err != nil {",
        "\t\treturn err",
        "\t}",
        "\t",
        "\tvar existingSettings map[string]interface{}",
        "\tif err := json.Unmarshal(existingContent, \u0026existingSettings); err != nil {",
        "\t\treturn fmt.Errorf(\"failed to parse existing settings: %v\", err)",
        "\t}",
        "\t",
        "\t// Parse AI Code Tracker settings",
        "\tvar aictSettings map[string]interface{}",
        "\tif err := json.Unmarshal([]byte(templates.ClaudeSettingsJSON), \u0026aictSettings); err != nil {",
        "\t\treturn fmt.Errorf(\"failed to parse AICT settings: %v\", err)",
        "\t}",
        "\t",
        "\t// Merge hooks",
        "\texistingHooks, hasHooks := existingSettings[\"hooks\"].([]interface{})",
        "\tif !hasHooks {",
        "\t\texistingHooks = []interface{}{}",
        "\t}",
        "\t",
        "\taictHooks := aictSettings[\"hooks\"].([]interface{})",
        "\tmergedHooks := append(existingHooks, aictHooks...)",
        "\texistingSettings[\"hooks\"] = mergedHooks",
        "\t",
        "\t// Write merged settings",
        "\tmergedContent, err := json.MarshalIndent(existingSettings, \"\", \"  \")",
        "\tif err != nil {",
        "\t\treturn err",
        "\t}",
        "\t",
        "\treturn os.WriteFile(settingsPath, mergedContent, 0644)",
        "}",
        "",
        "func handleReset() error {",
        "\tbaseDir := defaultBaseDir",
        "\t",
        "\tfmt.Print(\"This will reset all tracking metrics to zero and set current codebase as baseline. Continue? (y/N): \")",
        "\treader := bufio.NewReader(os.Stdin)",
        "\tresponse, _ := reader.ReadString('\\n')",
        "\tresponse = strings.TrimSpace(strings.ToLower(response))",
        "\t",
        "\tif response != \"y\" \u0026\u0026 response != \"yes\" {",
        "\t\tfmt.Println(\"Reset cancelled.\")",
        "\t\treturn nil",
        "\t}",
        "\t",
        "\tmetricsStorage := storage.NewMetricsStorage(baseDir)",
        "\t",
        "\t// Reset metrics to zero",
        "\tresetMetrics := \u0026tracker.AnalysisResult{",
        "\t\tTotalLines:  0,",
        "\t\tAILines:     0,",
        "\t\tHumanLines:  0,",
        "\t\tPercentage:  0.0,",
        "\t\tLastUpdated: time.Now(),",
        "\t}",
        "\t",
        "\tif err := metricsStorage.SaveMetrics(resetMetrics); err != nil {",
        "\t\treturn fmt.Errorf(\"error resetting metrics: %v\", err)",
        "\t}",
        "\t",
        "\t// Clear all checkpoints",
        "\tcheckpointsDir := filepath.Join(baseDir, \"checkpoints\")",
        "\tif err := os.RemoveAll(checkpointsDir); err != nil {",
        "\t\treturn fmt.Errorf(\"error clearing checkpoints: %v\", err)",
        "\t}",
        "\tif err := os.MkdirAll(checkpointsDir, 0755); err != nil {",
        "\t\treturn fmt.Errorf(\"error recreating checkpoints directory: %v\", err)",
        "\t}",
        "\t",
        "\tfmt.Println(\"✓ Metrics reset to zero\")",
        "\tfmt.Println(\"✓ All checkpoints cleared\")",
        "\tfmt.Println()",
        "\tfmt.Println(\"AI Code Tracker has been reset. Current codebase will be the baseline for future tracking.\")",
        "\tfmt.Println(\"Next step: Use 'aict track -author human' to set current state as human baseline.\")",
        "\t",
        "\treturn nil",
        "}",
        "",
        "func copyFile(src, dst string) error {",
        "\tsourceFile, err := os.Open(src)",
        "\tif err != nil {",
        "\t\treturn err",
        "\t}",
        "\tdefer sourceFile.Close()",
        "",
        "\tdestFile, err := os.Create(dst)",
        "\tif err != nil {",
        "\t\treturn err",
        "\t}",
        "\tdefer destFile.Close()",
        "",
        "\t_, err = destFile.ReadFrom(sourceFile)",
        "\treturn err",
        "}",
        "",
        "func printUsage() {",
        "\tfmt.Println(\"AI Code Tracker (aict) - Track AI vs Human code contributions\")",
        "\tfmt.Println()",
        "\tfmt.Println(\"Usage:\")",
        "\tfmt.Println(\"  aict init                    Initialize tracking in current directory\")",
        "\tfmt.Println(\"  aict track -author \u003cname\u003e    Create a checkpoint for the specified author\")",
        "\tfmt.Println(\"  aict report                  Show current tracking metrics\")",
        "\tfmt.Println(\"  aict setup-hooks             Setup Claude Code and Git hooks for automatic tracking\")",
        "\tfmt.Println(\"  aict reset                   Reset metrics to start tracking from current codebase state\")",
        "}",
        "",
        "func getGitUserName() string {",
        "\tcmd := exec.Command(\"git\", \"config\", \"user.name\")",
        "\toutput, err := cmd.Output()",
        "\tif err != nil {",
        "\t\treturn \"\"",
        "\t}",
        "\treturn string(output)",
        "}"
      ]
    },
    "internal/git/diff.go": {
      "path": "internal/git/diff.go",
      "lines": [
        "package git",
        "",
        "import (",
        "\t\"fmt\"",
        "\t\"os/exec\"",
        "\t\"strings\"",
        ")",
        "",
        "type DiffAnalyzer struct{}",
        "",
        "func NewDiffAnalyzer() *DiffAnalyzer {",
        "\treturn \u0026DiffAnalyzer{}",
        "}",
        "",
        "func (d *DiffAnalyzer) GetDiff(fromCommit, toCommit string) (string, error) {",
        "\tcmd := exec.Command(\"git\", \"diff\", fromCommit, toCommit)",
        "\toutput, err := cmd.Output()",
        "\tif err != nil {",
        "\t\treturn \"\", fmt.Errorf(\"failed to get git diff: %w\", err)",
        "\t}",
        "\treturn string(output), nil",
        "}",
        "",
        "func (d *DiffAnalyzer) GetCommitAuthor(commit string) (string, error) {",
        "\tcmd := exec.Command(\"git\", \"show\", \"-s\", \"--format=%an\", commit)",
        "\toutput, err := cmd.Output()",
        "\tif err != nil {",
        "\t\treturn \"\", fmt.Errorf(\"failed to get commit author: %w\", err)",
        "\t}",
        "\treturn strings.TrimSpace(string(output)), nil",
        "}",
        "",
        "func (d *DiffAnalyzer) GetLatestCommit() (string, error) {",
        "\tcmd := exec.Command(\"git\", \"rev-parse\", \"HEAD\")",
        "\toutput, err := cmd.Output()",
        "\tif err != nil {",
        "\t\treturn \"\", fmt.Errorf(\"failed to get latest commit: %w\", err)",
        "\t}",
        "\treturn strings.TrimSpace(string(output)), nil",
        "}",
        "",
        "func (d *DiffAnalyzer) GetCommitDiff(commit string) (string, error) {",
        "\tcmd := exec.Command(\"git\", \"show\", commit)",
        "\toutput, err := cmd.Output()",
        "\tif err != nil {",
        "\t\treturn \"\", fmt.Errorf(\"failed to get commit diff: %w\", err)",
        "\t}",
        "\treturn string(output), nil",
        "}",
        "",
        "func (d *DiffAnalyzer) GetCurrentBranch() (string, error) {",
        "\tcmd := exec.Command(\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\")",
        "\toutput, err := cmd.Output()",
        "\tif err != nil {",
        "\t\treturn \"\", fmt.Errorf(\"failed to get current branch: %w\", err)",
        "\t}",
        "\treturn strings.TrimSpace(string(output)), nil",
        "}",
        "",
        "func (d *DiffAnalyzer) IsGitRepository() bool {",
        "\tcmd := exec.Command(\"git\", \"rev-parse\", \"--git-dir\")",
        "\terr := cmd.Run()",
        "\treturn err == nil",
        "}"
      ]
    },
    "internal/storage/json.go": {
      "path": "internal/storage/json.go",
      "lines": [
        "package storage",
        "",
        "import (",
        "\t\"encoding/json\"",
        "\t\"fmt\"",
        "\t\"os\"",
        "\t\"path/filepath\"",
        ")",
        "",
        "type JSONStorage struct {",
        "\tbaseDir string",
        "}",
        "",
        "func NewJSONStorage(baseDir string) *JSONStorage {",
        "\treturn \u0026JSONStorage{",
        "\t\tbaseDir: baseDir,",
        "\t}",
        "}",
        "",
        "func (js *JSONStorage) Save(filename string, data interface{}) error {",
        "\tfilePath := filepath.Join(js.baseDir, filename)",
        "\t",
        "\tdir := filepath.Dir(filePath)",
        "\tif err := os.MkdirAll(dir, 0755); err != nil {",
        "\t\treturn fmt.Errorf(\"failed to create directory: %w\", err)",
        "\t}",
        "",
        "\tjsonData, err := json.MarshalIndent(data, \"\", \"  \")",
        "\tif err != nil {",
        "\t\treturn fmt.Errorf(\"failed to marshal data: %w\", err)",
        "\t}",
        "",
        "\tif err := os.WriteFile(filePath, jsonData, 0644); err != nil {",
        "\t\treturn fmt.Errorf(\"failed to write file: %w\", err)",
        "\t}",
        "",
        "\treturn nil",
        "}",
        "",
        "func (js *JSONStorage) Load(filename string, data interface{}) error {",
        "\tfilePath := filepath.Join(js.baseDir, filename)",
        "\t",
        "\tfileData, err := os.ReadFile(filePath)",
        "\tif err != nil {",
        "\t\treturn fmt.Errorf(\"failed to read file: %w\", err)",
        "\t}",
        "",
        "\tif err := json.Unmarshal(fileData, data); err != nil {",
        "\t\treturn fmt.Errorf(\"failed to unmarshal data: %w\", err)",
        "\t}",
        "",
        "\treturn nil",
        "}",
        "",
        "func (js *JSONStorage) Exists(filename string) bool {",
        "\tfilePath := filepath.Join(js.baseDir, filename)",
        "\t_, err := os.Stat(filePath)",
        "\treturn err == nil",
        "}",
        "",
        "func (js *JSONStorage) Delete(filename string) error {",
        "\tfilePath := filepath.Join(js.baseDir, filename)",
        "\treturn os.Remove(filePath)",
        "}",
        "",
        "func (js *JSONStorage) List(pattern string) ([]string, error) {",
        "\tsearchPattern := filepath.Join(js.baseDir, pattern)",
        "\tmatches, err := filepath.Glob(searchPattern)",
        "\tif err != nil {",
        "\t\treturn nil, fmt.Errorf(\"failed to list files: %w\", err)",
        "\t}",
        "",
        "\tresult := make([]string, len(matches))",
        "\tfor i, match := range matches {",
        "\t\tresult[i], _ = filepath.Rel(js.baseDir, match)",
        "\t}",
        "",
        "\treturn result, nil",
        "}"
      ]
    },
    "internal/storage/metrics.go": {
      "path": "internal/storage/metrics.go",
      "lines": [
        "package storage",
        "",
        "import (",
        "\t\"fmt\"",
        "\t\"time\"",
        "",
        "\t\"github.com/y-hirakawa/ai-code-tracker/internal/tracker\"",
        ")",
        "",
        "type MetricsStorage struct {",
        "\tstorage *JSONStorage",
        "}",
        "",
        "func NewMetricsStorage(baseDir string) *MetricsStorage {",
        "\treturn \u0026MetricsStorage{",
        "\t\tstorage: NewJSONStorage(baseDir),",
        "\t}",
        "}",
        "",
        "func (ms *MetricsStorage) SaveMetrics(result *tracker.AnalysisResult) error {",
        "\tfilename := \"metrics/current.json\"",
        "\treturn ms.storage.Save(filename, result)",
        "}",
        "",
        "func (ms *MetricsStorage) LoadMetrics() (*tracker.AnalysisResult, error) {",
        "\tfilename := \"metrics/current.json\"",
        "\tvar result tracker.AnalysisResult",
        "\t",
        "\tif !ms.storage.Exists(filename) {",
        "\t\treturn \u0026tracker.AnalysisResult{",
        "\t\t\tTotalLines:  0,",
        "\t\t\tAILines:     0,",
        "\t\t\tHumanLines:  0,",
        "\t\t\tPercentage:  0,",
        "\t\t\tLastUpdated: time.Now(),",
        "\t\t}, nil",
        "\t}",
        "\t",
        "\tif err := ms.storage.Load(filename, \u0026result); err != nil {",
        "\t\treturn nil, fmt.Errorf(\"failed to load metrics: %w\", err)",
        "\t}",
        "\t",
        "\treturn \u0026result, nil",
        "}",
        "",
        "func (ms *MetricsStorage) SaveConfig(config *tracker.Config) error {",
        "\tfilename := \"config.json\"",
        "\treturn ms.storage.Save(filename, config)",
        "}",
        "",
        "func (ms *MetricsStorage) LoadConfig() (*tracker.Config, error) {",
        "\tfilename := \"config.json\"",
        "\tvar config tracker.Config",
        "\t",
        "\tif !ms.storage.Exists(filename) {",
        "\t\treturn ms.getDefaultConfig(), nil",
        "\t}",
        "\t",
        "\tif err := ms.storage.Load(filename, \u0026config); err != nil {",
        "\t\treturn nil, fmt.Errorf(\"failed to load config: %w\", err)",
        "\t}",
        "\t",
        "\treturn \u0026config, nil",
        "}",
        "",
        "func (ms *MetricsStorage) getDefaultConfig() *tracker.Config {",
        "\treturn \u0026tracker.Config{",
        "\t\tTargetAIPercentage: 80.0,",
        "\t\tTrackedExtensions:  []string{\".go\", \".py\", \".js\", \".ts\", \".java\", \".cpp\", \".c\", \".h\", \".rs\"},",
        "\t\tExcludePatterns:    []string{\"*_test.go\", \"*.test.js\", \"*.spec.ts\", \"*_generated.go\"},",
        "\t\tAuthorMappings:     make(map[string]string),",
        "\t}",
        "}",
        "",
        "func (ms *MetricsStorage) ArchiveMetrics(result *tracker.AnalysisResult) error {",
        "\ttimestamp := result.LastUpdated.Format(\"20060102_150405\")",
        "\tfilename := fmt.Sprintf(\"metrics/archive/%s.json\", timestamp)",
        "\treturn ms.storage.Save(filename, result)",
        "}"
      ]
    },
    "internal/templates/hooks.go": {
      "path": "internal/templates/hooks.go",
      "lines": [
        "package templates",
        "",
        "// PreToolUseHook template for recording human state before Claude edits",
        "const PreToolUseHook = `#!/bin/bash",
        "",
        "# AI Code Tracker - PreToolUse Hook",
        "# Records human code state before Claude Code makes changes",
        "",
        "set -e",
        "",
        "# Get project directory",
        "PROJECT_DIR=\"${CLAUDE_PROJECT_DIR:-$(pwd)}\"",
        "AICT_BIN=\"$PROJECT_DIR/bin/aict\"",
        "",
        "# Check if aict binary exists",
        "if [[ ! -f \"$AICT_BIN\" ]]; then",
        "    echo \"Warning: AI Code Tracker not found at $AICT_BIN\" \u003e\u00262",
        "    exit 0",
        "fi",
        "",
        "# Initialize if not already done",
        "if [[ ! -d \"$PROJECT_DIR/.ai_code_tracking\" ]]; then",
        "    echo \"Initializing AI Code Tracker...\" \u003e\u00262",
        "    \"$AICT_BIN\" init",
        "fi",
        "",
        "# Read hook input (JSON) from stdin",
        "INPUT=$(cat)",
        "",
        "# Extract tool information",
        "TOOL_NAME=$(echo \"$INPUT\" | jq -r '.tool_name // \"unknown\"')",
        "SESSION_ID=$(echo \"$INPUT\" | jq -r '.session_id // \"unknown\"')",
        "",
        "# Log the pre-tool-use event",
        "echo \"AI Code Tracker: Recording human state before $TOOL_NAME (session: ${SESSION_ID:0:8}...)\" \u003e\u00262",
        "",
        "# Record human checkpoint before Claude makes changes",
        "\"$AICT_BIN\" track -author human",
        "",
        "# Exit successfully to allow tool execution",
        "exit 0`",
        "",
        "// PostToolUseHook template for recording AI state after Claude edits",
        "const PostToolUseHook = `#!/bin/bash",
        "",
        "# AI Code Tracker - PostToolUse Hook  ",
        "# Records AI code state after Claude Code makes changes",
        "",
        "set -e",
        "",
        "# Get project directory",
        "PROJECT_DIR=\"${CLAUDE_PROJECT_DIR:-$(pwd)}\"",
        "AICT_BIN=\"$PROJECT_DIR/bin/aict\"",
        "",
        "# Check if aict binary exists",
        "if [[ ! -f \"$AICT_BIN\" ]]; then",
        "    echo \"Warning: AI Code Tracker not found at $AICT_BIN\" \u003e\u00262",
        "    exit 0",
        "fi",
        "",
        "# Read hook input (JSON) from stdin",
        "INPUT=$(cat)",
        "",
        "# Extract tool information",
        "TOOL_NAME=$(echo \"$INPUT\" | jq -r '.tool_name // \"unknown\"')",
        "SESSION_ID=$(echo \"$INPUT\" | jq -r '.session_id // \"unknown\"')",
        "TOOL_RESPONSE=$(echo \"$INPUT\" | jq -r '.tool_response // \"{}\"')",
        "",
        "# Check if tool was successful",
        "if echo \"$TOOL_RESPONSE\" | jq -e '.error' \u003e /dev/null 2\u003e\u00261; then",
        "    echo \"AI Code Tracker: Skipping tracking due to tool error\" \u003e\u00262",
        "    exit 0",
        "fi",
        "",
        "# Log the post-tool-use event",
        "echo \"AI Code Tracker: Recording AI state after $TOOL_NAME (session: ${SESSION_ID:0:8}...)\" \u003e\u00262",
        "",
        "# Record AI checkpoint after Claude makes changes",
        "\"$AICT_BIN\" track -author claude",
        "",
        "# Generate and display current report",
        "echo \"AI Code Tracker: Current status:\" \u003e\u00262",
        "\"$AICT_BIN\" report \u003e\u00262",
        "",
        "# Exit successfully",
        "exit 0`",
        "",
        "// PostCommitHook template for Git post-commit hook",
        "const PostCommitHook = `#!/bin/bash",
        "",
        "# AI Code Tracker - Git Post-Commit Hook",
        "# Updates tracking metrics after each commit",
        "",
        "set -e",
        "",
        "# Get project directory (Git hook doesn't have CLAUDE_PROJECT_DIR)",
        "PROJECT_DIR=\"$(git rev-parse --show-toplevel)\"",
        "AICT_BIN=\"$PROJECT_DIR/bin/aict\"",
        "",
        "# Check if aict binary exists",
        "if [[ ! -f \"$AICT_BIN\" ]]; then",
        "    exit 0",
        "fi",
        "",
        "# Check if AI Code Tracker is initialized",
        "if [[ ! -d \"$PROJECT_DIR/.ai_code_tracking\" ]]; then",
        "    exit 0",
        "fi",
        "",
        "# Get commit information",
        "COMMIT_HASH=$(git rev-parse HEAD)",
        "COMMIT_AUTHOR=$(git log -1 --format='%an')",
        "COMMIT_MESSAGE=$(git log -1 --format='%s')",
        "",
        "echo \"AI Code Tracker: Post-commit analysis for $COMMIT_HASH\" \u003e\u00262",
        "echo \"Author: $COMMIT_AUTHOR\" \u003e\u00262",
        "echo \"Message: $COMMIT_MESSAGE\" \u003e\u00262",
        "",
        "# Display current tracking status",
        "\"$AICT_BIN\" report \u003e\u00262",
        "",
        "# Archive current metrics with commit info",
        "TIMESTAMP=$(date +\"%Y%m%d_%H%M%S\")",
        "METRICS_FILE=\"$PROJECT_DIR/.ai_code_tracking/metrics/current.json\"",
        "ARCHIVE_FILE=\"$PROJECT_DIR/.ai_code_tracking/metrics/archive/commit_${COMMIT_HASH:0:8}_${TIMESTAMP}.json\"",
        "",
        "if [[ -f \"$METRICS_FILE\" ]]; then",
        "    mkdir -p \"$(dirname \"$ARCHIVE_FILE\")\"",
        "    # Add commit info to archived metrics",
        "    jq --arg commit \"$COMMIT_HASH\" --arg author \"$COMMIT_AUTHOR\" --arg message \"$COMMIT_MESSAGE\" \\",
        "       '. + {\"commit_hash\": $commit, \"commit_author\": $author, \"commit_message\": $message}' \\",
        "       \"$METRICS_FILE\" \u003e \"$ARCHIVE_FILE\"",
        "    echo \"AI Code Tracker: Metrics archived to $ARCHIVE_FILE\" \u003e\u00262",
        "fi",
        "",
        "exit 0`",
        "",
        "// ClaudeSettingsJSON template for Claude Code hook configuration",
        "const ClaudeSettingsJSON = `{",
        "  \"hooks\": [",
        "    {",
        "      \"event\": \"PreToolUse\",",
        "      \"matcher\": \"Write|Edit|MultiEdit\",",
        "      \"hooks\": [",
        "        {",
        "          \"type\": \"command\",",
        "          \"command\": \"$CLAUDE_PROJECT_DIR/.ai_code_tracking/hooks/pre-tool-use.sh\"",
        "        }",
        "      ]",
        "    },",
        "    {",
        "      \"event\": \"PostToolUse\", ",
        "      \"matcher\": \"Write|Edit|MultiEdit\",",
        "      \"hooks\": [",
        "        {",
        "          \"type\": \"command\",",
        "          \"command\": \"$CLAUDE_PROJECT_DIR/.ai_code_tracking/hooks/post-tool-use.sh\"",
        "        }",
        "      ]",
        "    }",
        "  ]",
        "}`"
      ]
    },
    "internal/tracker/analyzer.go": {
      "path": "internal/tracker/analyzer.go",
      "lines": [
        "package tracker",
        "",
        "import (",
        "\t\"fmt\"",
        "\t\"strings\"",
        ")",
        "",
        "type Analyzer struct {",
        "\tconfig *Config",
        "}",
        "",
        "func NewAnalyzer(config *Config) *Analyzer {",
        "\treturn \u0026Analyzer{",
        "\t\tconfig: config,",
        "\t}",
        "}",
        "",
        "func (a *Analyzer) AnalyzeCheckpoints(before, after *Checkpoint) (*AnalysisResult, error) {",
        "\tresult := \u0026AnalysisResult{",
        "\t\tLastUpdated: after.Timestamp,",
        "\t}",
        "",
        "\tisAIAuthor := a.IsAIAuthor(after.Author)",
        "",
        "\tfor path, afterFile := range after.Files {",
        "\t\tbeforeFile, exists := before.Files[path]",
        "\t\tif !exists {",
        "\t\t\t// New file",
        "\t\t\tif isAIAuthor {",
        "\t\t\t\tresult.AILines += len(afterFile.Lines)",
        "\t\t\t} else {",
        "\t\t\t\tresult.HumanLines += len(afterFile.Lines)",
        "\t\t\t}",
        "\t\t\tresult.TotalLines += len(afterFile.Lines)",
        "\t\t\tcontinue",
        "\t\t}",
        "",
        "\t\t// Modified file - count added lines",
        "\t\tstats := a.compareFiles(beforeFile, afterFile, isAIAuthor)",
        "\t\tresult.AILines += stats.AILines",
        "\t\tresult.HumanLines += stats.HumanLines",
        "\t\t// Don't add total lines here - we only want the diff",
        "\t}",
        "",
        "\tfor path, beforeFile := range before.Files {",
        "\t\tif _, exists := after.Files[path]; !exists {",
        "\t\t\tresult.TotalLines -= len(beforeFile.Lines)",
        "\t\t}",
        "\t}",
        "",
        "\tif result.TotalLines \u003e 0 {",
        "\t\tresult.Percentage = float64(result.AILines) / float64(result.TotalLines) * 100",
        "\t}",
        "",
        "\treturn result, nil",
        "}",
        "",
        "func (a *Analyzer) AnalyzeFromGitDiff(diff string, currentMetrics *AnalysisResult) (*AnalysisResult, error) {",
        "\tlines := strings.Split(diff, \"\\n\")",
        "\tnewAILines := 0",
        "\tnewHumanLines := 0",
        "",
        "\tisAICommit := false",
        "\tfor _, line := range lines {",
        "\t\tif strings.HasPrefix(line, \"Author:\") {",
        "\t\t\tauthor := strings.TrimSpace(strings.TrimPrefix(line, \"Author:\"))",
        "\t\t\tisAICommit = a.IsAIAuthor(author)",
        "\t\t}",
        "",
        "\t\tif strings.HasPrefix(line, \"+\") \u0026\u0026 !strings.HasPrefix(line, \"+++\") {",
        "\t\t\tif isAICommit {",
        "\t\t\t\tnewAILines++",
        "\t\t\t} else {",
        "\t\t\t\tnewHumanLines++",
        "\t\t\t}",
        "\t\t}",
        "\t}",
        "",
        "\tresult := \u0026AnalysisResult{",
        "\t\tTotalLines:  currentMetrics.TotalLines + newAILines + newHumanLines,",
        "\t\tAILines:     currentMetrics.AILines + newAILines,",
        "\t\tHumanLines:  currentMetrics.HumanLines + newHumanLines,",
        "\t\tLastUpdated: currentMetrics.LastUpdated,",
        "\t}",
        "",
        "\tif result.TotalLines \u003e 0 {",
        "\t\tresult.Percentage = float64(result.AILines) / float64(result.TotalLines) * 100",
        "\t}",
        "",
        "\treturn result, nil",
        "}",
        "",
        "func (a *Analyzer) GetFileStats(checkpoint *Checkpoint) []FileStats {",
        "\tstats := make([]FileStats, 0, len(checkpoint.Files))",
        "\t",
        "\tfor path, file := range checkpoint.Files {",
        "\t\tstat := FileStats{",
        "\t\t\tPath:       path,",
        "\t\t\tTotalLines: len(file.Lines),",
        "\t\t}",
        "\t\t",
        "\t\tif a.IsAIAuthor(checkpoint.Author) {",
        "\t\t\tstat.AILines = len(file.Lines)",
        "\t\t} else {",
        "\t\t\tstat.HumanLines = len(file.Lines)",
        "\t\t}",
        "\t\t",
        "\t\tstats = append(stats, stat)",
        "\t}",
        "\t",
        "\treturn stats",
        "}",
        "",
        "func (a *Analyzer) compareFiles(before, after FileContent, isAIAuthor bool) FileStats {",
        "\tstats := FileStats{",
        "\t\tPath: after.Path,",
        "\t}",
        "",
        "\t// For now, just count the difference in total lines",
        "\t// This is a simplified approach that assumes lines are only added, not modified",
        "\tlineDiff := len(after.Lines) - len(before.Lines)",
        "\t",
        "\tif lineDiff \u003e 0 {",
        "\t\tif isAIAuthor {",
        "\t\t\tstats.AILines = lineDiff",
        "\t\t} else {",
        "\t\t\tstats.HumanLines = lineDiff",
        "\t\t}",
        "\t}",
        "",
        "\treturn stats",
        "}",
        "",
        "func (a *Analyzer) IsAIAuthor(author string) bool {",
        "\taiAuthors := []string{\"claude\", \"ai\", \"assistant\", \"bot\"}",
        "\tauthorLower := strings.ToLower(author)",
        "\t",
        "\tif mapping, exists := a.config.AuthorMappings[author]; exists {",
        "\t\tauthorLower = strings.ToLower(mapping)",
        "\t}",
        "\t",
        "\tfor _, aiAuthor := range aiAuthors {",
        "\t\tif strings.Contains(authorLower, aiAuthor) {",
        "\t\t\treturn true",
        "\t\t}",
        "\t}",
        "\t",
        "\treturn false",
        "}",
        "",
        "func (a *Analyzer) GenerateReport(result *AnalysisResult) string {",
        "\tprogress := result.Percentage / a.config.TargetAIPercentage * 100",
        "\tif progress \u003e 100 {",
        "\t\tprogress = 100",
        "\t}",
        "",
        "\treport := fmt.Sprintf(`AI Code Tracking Report",
        "======================",
        "Total Lines: %d",
        "AI Lines: %d (%.1f%%)",
        "Human Lines: %d (%.1f%%)",
        "",
        "Target: %.1f%% AI code",
        "Progress: %.1f%%",
        "",
        "Last Updated: %s",
        "`,",
        "\t\tresult.TotalLines,",
        "\t\tresult.AILines, result.Percentage,",
        "\t\tresult.HumanLines, 100-result.Percentage,",
        "\t\ta.config.TargetAIPercentage,",
        "\t\tprogress,",
        "\t\tresult.LastUpdated.Format(\"2006-01-02 15:04:05\"))",
        "",
        "\treturn report",
        "}"
      ]
    },
    "internal/tracker/checkpoint.go": {
      "path": "internal/tracker/checkpoint.go",
      "lines": [
        "package tracker",
        "",
        "import (",
        "\t\"crypto/md5\"",
        "\t\"encoding/json\"",
        "\t\"fmt\"",
        "\t\"io\"",
        "\t\"os\"",
        "\t\"path/filepath\"",
        "\t\"strings\"",
        "\t\"time\"",
        ")",
        "",
        "type CheckpointManager struct {",
        "\tbaseDir string",
        "}",
        "",
        "func NewCheckpointManager(baseDir string) *CheckpointManager {",
        "\treturn \u0026CheckpointManager{",
        "\t\tbaseDir: baseDir,",
        "\t}",
        "}",
        "",
        "func (cm *CheckpointManager) CreateCheckpoint(author string, extensions []string) (*Checkpoint, error) {",
        "\tcheckpoint := \u0026Checkpoint{",
        "\t\tID:        cm.generateID(),",
        "\t\tTimestamp: time.Now(),",
        "\t\tAuthor:    author,",
        "\t\tFiles:     make(map[string]FileContent),",
        "\t}",
        "",
        "\terr := cm.scanCodeFiles(\".\", extensions, checkpoint)",
        "\tif err != nil {",
        "\t\treturn nil, fmt.Errorf(\"failed to scan code files: %w\", err)",
        "\t}",
        "",
        "\treturn checkpoint, nil",
        "}",
        "",
        "func (cm *CheckpointManager) SaveCheckpoint(checkpoint *Checkpoint) error {",
        "\tcheckpointDir := filepath.Join(cm.baseDir, \"checkpoints\")",
        "\tif err := os.MkdirAll(checkpointDir, 0755); err != nil {",
        "\t\treturn fmt.Errorf(\"failed to create checkpoint directory: %w\", err)",
        "\t}",
        "",
        "\tfilename := filepath.Join(checkpointDir, fmt.Sprintf(\"%s_%s.json\", checkpoint.Author, checkpoint.ID))",
        "\tdata, err := json.MarshalIndent(checkpoint, \"\", \"  \")",
        "\tif err != nil {",
        "\t\treturn fmt.Errorf(\"failed to marshal checkpoint: %w\", err)",
        "\t}",
        "",
        "\tif err := os.WriteFile(filename, data, 0644); err != nil {",
        "\t\treturn fmt.Errorf(\"failed to write checkpoint file: %w\", err)",
        "\t}",
        "",
        "\treturn nil",
        "}",
        "",
        "func (cm *CheckpointManager) LoadCheckpoint(filename string) (*Checkpoint, error) {",
        "\tdata, err := os.ReadFile(filename)",
        "\tif err != nil {",
        "\t\treturn nil, fmt.Errorf(\"failed to read checkpoint file: %w\", err)",
        "\t}",
        "",
        "\tvar checkpoint Checkpoint",
        "\tif err := json.Unmarshal(data, \u0026checkpoint); err != nil {",
        "\t\treturn nil, fmt.Errorf(\"failed to unmarshal checkpoint: %w\", err)",
        "\t}",
        "",
        "\treturn \u0026checkpoint, nil",
        "}",
        "",
        "func (cm *CheckpointManager) GetLatestCheckpoints(author string, count int) ([]*Checkpoint, error) {",
        "\tcheckpointDir := filepath.Join(cm.baseDir, \"checkpoints\")",
        "\tvar pattern string",
        "\tif author == \"*\" {",
        "\t\tpattern = filepath.Join(checkpointDir, \"*.json\")",
        "\t} else {",
        "\t\tpattern = filepath.Join(checkpointDir, fmt.Sprintf(\"%s_*.json\", author))",
        "\t}",
        "\t",
        "\tfiles, err := filepath.Glob(pattern)",
        "\tif err != nil {",
        "\t\treturn nil, fmt.Errorf(\"failed to list checkpoints: %w\", err)",
        "\t}",
        "",
        "\tcheckpoints := make([]*Checkpoint, 0, len(files))",
        "\tfor _, file := range files {",
        "\t\tcp, err := cm.LoadCheckpoint(file)",
        "\t\tif err != nil {",
        "\t\t\tcontinue",
        "\t\t}",
        "\t\tcheckpoints = append(checkpoints, cp)",
        "\t}",
        "",
        "\tif len(checkpoints) \u003e count \u0026\u0026 count \u003e 0 {",
        "\t\tcheckpoints = checkpoints[len(checkpoints)-count:]",
        "\t}",
        "",
        "\treturn checkpoints, nil",
        "}",
        "",
        "func (cm *CheckpointManager) scanCodeFiles(root string, extensions []string, checkpoint *Checkpoint) error {",
        "\textMap := make(map[string]bool)",
        "\tfor _, ext := range extensions {",
        "\t\textMap[ext] = true",
        "\t}",
        "",
        "\treturn filepath.Walk(root, func(path string, info os.FileInfo, err error) error {",
        "\t\tif err != nil {",
        "\t\t\treturn err",
        "\t\t}",
        "",
        "\t\tif info.IsDir() || strings.HasPrefix(path, \".ai_code_tracking\") || strings.HasPrefix(path, \".git\") {",
        "\t\t\treturn nil",
        "\t\t}",
        "",
        "\t\text := filepath.Ext(path)",
        "\t\tif !extMap[ext] {",
        "\t\t\treturn nil",
        "\t\t}",
        "",
        "\t\tcontent, err := cm.readFileLines(path)",
        "\t\tif err != nil {",
        "\t\t\treturn err",
        "\t\t}",
        "",
        "\t\tcheckpoint.Files[path] = FileContent{",
        "\t\t\tPath:  path,",
        "\t\t\tLines: content,",
        "\t\t}",
        "",
        "\t\treturn nil",
        "\t})",
        "}",
        "",
        "func (cm *CheckpointManager) readFileLines(path string) ([]string, error) {",
        "\tdata, err := os.ReadFile(path)",
        "\tif err != nil {",
        "\t\treturn nil, err",
        "\t}",
        "",
        "\tlines := strings.Split(string(data), \"\\n\")",
        "\treturn lines, nil",
        "}",
        "",
        "func (cm *CheckpointManager) generateID() string {",
        "\th := md5.New()",
        "\tio.WriteString(h, time.Now().String())",
        "\treturn fmt.Sprintf(\"%x\", h.Sum(nil))[:8]",
        "}"
      ]
    },
    "internal/tracker/types.go": {
      "path": "internal/tracker/types.go",
      "lines": [
        "package tracker",
        "",
        "import \"time\"",
        "",
        "type Checkpoint struct {",
        "\tID        string                 `json:\"id\"`",
        "\tTimestamp time.Time              `json:\"timestamp\"`",
        "\tAuthor    string                 `json:\"author\"`",
        "\tFiles     map[string]FileContent `json:\"files\"`",
        "}",
        "",
        "type FileContent struct {",
        "\tPath  string   `json:\"path\"`",
        "\tLines []string `json:\"lines\"`",
        "}",
        "",
        "type AnalysisResult struct {",
        "\tTotalLines  int     `json:\"total_lines\"`",
        "\tAILines     int     `json:\"ai_lines\"`",
        "\tHumanLines  int     `json:\"human_lines\"`",
        "\tPercentage  float64 `json:\"percentage\"`",
        "\tLastUpdated time.Time `json:\"last_updated\"`",
        "}",
        "",
        "type FileStats struct {",
        "\tPath       string `json:\"path\"`",
        "\tTotalLines int    `json:\"total_lines\"`",
        "\tAILines    int    `json:\"ai_lines\"`",
        "\tHumanLines int    `json:\"human_lines\"`",
        "}",
        "",
        "type Config struct {",
        "\tTargetAIPercentage float64  `json:\"target_ai_percentage\"`",
        "\tTrackedExtensions  []string `json:\"tracked_extensions\"`",
        "\tExcludePatterns    []string `json:\"exclude_patterns\"`",
        "\tAuthorMappings     map[string]string `json:\"author_mappings\"`",
        "}"
      ]
    },
    "test/example.swift": {
      "path": "test/example.swift",
      "lines": [
        "import Foundation",
        "",
        "// Simple vocabulary learning app",
        "struct VocabularyCard {",
        "    let word: String",
        "    let translation: String",
        "}",
        "",
        "let cards = [",
        "    VocabularyCard(word: \"Hello\", translation: \"こんにちは\"),",
        "    VocabularyCard(word: \"Thank you\", translation: \"ありがとう\")",
        "    VocabularyCard(word: \"Fine?\", translation: \"元気？\")",
        "    VocabularyCard(word: \"Good bye\", translation: \"さようなら\")",
        "]",
        "",
        "print(\"Learning \\(cards.count) words\")"
      ]
    }
  }
}