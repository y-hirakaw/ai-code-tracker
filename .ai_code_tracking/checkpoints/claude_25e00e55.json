{
  "id": "25e00e55",
  "timestamp": "2025-07-30T15:52:09.744128+09:00",
  "author": "claude",
  "files": {
    "cmd/aict/main.go": {
      "path": "cmd/aict/main.go",
      "lines": [
        "package main",
        "",
        "import (",
        "\t\"flag\"",
        "\t\"fmt\"",
        "\t\"os\"",
        "\t\"os/exec\"",
        "",
        "\t\"github.com/y-hirakawa/ai-code-tracker/internal/git\"",
        "\t\"github.com/y-hirakawa/ai-code-tracker/internal/storage\"",
        "\t\"github.com/y-hirakawa/ai-code-tracker/internal/tracker\"",
        ")",
        "",
        "const (",
        "\tdefaultBaseDir = \".ai_tracking\"",
        ")",
        "",
        "func main() {",
        "\tif len(os.Args) \u003c 2 {",
        "\t\tprintUsage()",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\tcommand := os.Args[1]",
        "\tswitch command {",
        "\tcase \"init\":",
        "\t\thandleInit()",
        "\tcase \"track\":",
        "\t\thandleTrack()",
        "\tcase \"report\":",
        "\t\thandleReport()",
        "\tdefault:",
        "\t\tfmt.Printf(\"Unknown command: %s\\n\", command)",
        "\t\tprintUsage()",
        "\t\tos.Exit(1)",
        "\t}",
        "}",
        "",
        "func handleInit() {",
        "\tbaseDir := defaultBaseDir",
        "\t",
        "\tif err := os.MkdirAll(baseDir, 0755); err != nil {",
        "\t\tfmt.Printf(\"Error creating tracking directory: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\tmetricsStorage := storage.NewMetricsStorage(baseDir)",
        "\tconfig := \u0026tracker.Config{",
        "\t\tTargetAIPercentage: 80.0,",
        "\t\tTrackedExtensions:  []string{\".go\", \".py\", \".js\", \".ts\", \".java\", \".cpp\", \".c\", \".h\", \".rs\"},",
        "\t\tExcludePatterns:    []string{\"*_test.go\", \"*.test.js\", \"*.spec.ts\", \"*_generated.go\"},",
        "\t\tAuthorMappings:     make(map[string]string),",
        "\t}",
        "",
        "\tif err := metricsStorage.SaveConfig(config); err != nil {",
        "\t\tfmt.Printf(\"Error saving config: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\tgitAnalyzer := git.NewDiffAnalyzer()",
        "\tif gitAnalyzer.IsGitRepository() {",
        "\t\tuserName := getGitUserName()",
        "\t\tif userName != \"\" {",
        "\t\t\tconfig.AuthorMappings[userName] = \"human\"",
        "\t\t\tmetricsStorage.SaveConfig(config)",
        "\t\t}",
        "\t}",
        "",
        "\tfmt.Println(\"AI Code Tracker initialized successfully!\")",
        "\tfmt.Printf(\"Configuration saved to %s/config.json\\n\", baseDir)",
        "}",
        "",
        "func handleTrack() {",
        "\tfs := flag.NewFlagSet(\"track\", flag.ExitOnError)",
        "\tauthor := fs.String(\"author\", \"\", \"Author of the checkpoint (required)\")",
        "\tfs.Parse(os.Args[2:])",
        "",
        "\tif *author == \"\" {",
        "\t\tfmt.Println(\"Error: -author flag is required\")",
        "\t\tfmt.Println(\"Usage: aict track -author \u003cauthor_name\u003e\")",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\tbaseDir := defaultBaseDir",
        "\tmetricsStorage := storage.NewMetricsStorage(baseDir)",
        "\t",
        "\tconfig, err := metricsStorage.LoadConfig()",
        "\tif err != nil {",
        "\t\tfmt.Printf(\"Error loading config: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\tcheckpointMgr := tracker.NewCheckpointManager(baseDir)",
        "\tcheckpoint, err := checkpointMgr.CreateCheckpoint(*author, config.TrackedExtensions)",
        "\tif err != nil {",
        "\t\tfmt.Printf(\"Error creating checkpoint: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\tif err := checkpointMgr.SaveCheckpoint(checkpoint); err != nil {",
        "\t\tfmt.Printf(\"Error saving checkpoint: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\t// Load current metrics",
        "\tcurrentMetrics, err := metricsStorage.LoadMetrics()",
        "\tif err != nil {",
        "\t\tfmt.Printf(\"Error loading metrics: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\t// Get all checkpoints to find the previous one",
        "\tallCheckpoints, err := checkpointMgr.GetLatestCheckpoints(\"*\", 100)",
        "\tif err != nil {",
        "\t\tfmt.Printf(\"Error getting checkpoints: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\t// Find the last checkpoint before this one",
        "\tvar previousCheckpoint *tracker.Checkpoint",
        "\tfor i := len(allCheckpoints) - 1; i \u003e= 0; i-- {",
        "\t\tif allCheckpoints[i].ID != checkpoint.ID {",
        "\t\t\tpreviousCheckpoint = allCheckpoints[i]",
        "\t\t\tbreak",
        "\t\t}",
        "\t}",
        "",
        "\tif previousCheckpoint == nil {",
        "\t\t// First checkpoint - all lines are from this author",
        "\t\tif analyzer := tracker.NewAnalyzer(config); analyzer.IsAIAuthor(*author) {",
        "\t\t\tcurrentMetrics.AILines = countTotalLines(checkpoint)",
        "\t\t\tcurrentMetrics.TotalLines = currentMetrics.AILines",
        "\t\t} else {",
        "\t\t\tcurrentMetrics.HumanLines = countTotalLines(checkpoint)",
        "\t\t\tcurrentMetrics.TotalLines = currentMetrics.HumanLines",
        "\t\t}",
        "\t\tcurrentMetrics.LastUpdated = checkpoint.Timestamp",
        "\t} else {",
        "\t\t// Analyze diff between previous and current checkpoint",
        "\t\tanalyzer := tracker.NewAnalyzer(config)",
        "\t\tresult, err := analyzer.AnalyzeCheckpoints(previousCheckpoint, checkpoint)",
        "\t\tif err != nil {",
        "\t\t\tfmt.Printf(\"Error analyzing checkpoints: %v\\n\", err)",
        "\t\t\tos.Exit(1)",
        "\t\t}",
        "",
        "\t\t// Add to current metrics",
        "\t\tcurrentMetrics.AILines += result.AILines",
        "\t\tcurrentMetrics.HumanLines += result.HumanLines",
        "\t\t// Recalculate total lines from the latest checkpoint",
        "\t\tcurrentMetrics.TotalLines = countTotalLines(checkpoint)",
        "\t\t// Ensure human lines = total - AI lines",
        "\t\tcurrentMetrics.HumanLines = currentMetrics.TotalLines - currentMetrics.AILines",
        "\t\tcurrentMetrics.LastUpdated = result.LastUpdated",
        "\t}",
        "",
        "\tif currentMetrics.TotalLines \u003e 0 {",
        "\t\tcurrentMetrics.Percentage = float64(currentMetrics.AILines) / float64(currentMetrics.TotalLines) * 100",
        "\t}",
        "",
        "\tif err := metricsStorage.SaveMetrics(currentMetrics); err != nil {",
        "\t\tfmt.Printf(\"Error saving metrics: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\tfmt.Println(\"Checkpoint saved and metrics updated!\")",
        "\tanalyzer := tracker.NewAnalyzer(config)",
        "\tfmt.Println(analyzer.GenerateReport(currentMetrics))",
        "}",
        "",
        "func handleReport() {",
        "\tbaseDir := defaultBaseDir",
        "\tmetricsStorage := storage.NewMetricsStorage(baseDir)",
        "\t",
        "\tconfig, err := metricsStorage.LoadConfig()",
        "\tif err != nil {",
        "\t\tfmt.Printf(\"Error loading config: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\tmetrics, err := metricsStorage.LoadMetrics()",
        "\tif err != nil {",
        "\t\tfmt.Printf(\"Error loading metrics: %v\\n\", err)",
        "\t\tos.Exit(1)",
        "\t}",
        "",
        "\tanalyzer := tracker.NewAnalyzer(config)",
        "\tfmt.Println(analyzer.GenerateReport(metrics))",
        "}",
        "",
        "func countTotalLines(checkpoint *tracker.Checkpoint) int {",
        "\ttotal := 0",
        "\tfor _, file := range checkpoint.Files {",
        "\t\ttotal += len(file.Lines)",
        "\t}",
        "\treturn total",
        "}",
        "",
        "func printUsage() {",
        "\tfmt.Println(\"AI Code Tracker (aict) - Track AI vs Human code contributions\")",
        "\tfmt.Println()",
        "\tfmt.Println(\"Usage:\")",
        "\tfmt.Println(\"  aict init                    Initialize tracking in current directory\")",
        "\tfmt.Println(\"  aict track -author \u003cname\u003e    Create a checkpoint for the specified author\")",
        "\tfmt.Println(\"  aict report                  Show current tracking metrics\")",
        "}",
        "",
        "func getGitUserName() string {",
        "\tcmd := exec.Command(\"git\", \"config\", \"user.name\")",
        "\toutput, err := cmd.Output()",
        "\tif err != nil {",
        "\t\treturn \"\"",
        "\t}",
        "\treturn string(output)",
        "}"
      ]
    },
    "internal/git/diff.go": {
      "path": "internal/git/diff.go",
      "lines": [
        "package git",
        "",
        "import (",
        "\t\"fmt\"",
        "\t\"os/exec\"",
        "\t\"strings\"",
        ")",
        "",
        "type DiffAnalyzer struct{}",
        "",
        "func NewDiffAnalyzer() *DiffAnalyzer {",
        "\treturn \u0026DiffAnalyzer{}",
        "}",
        "",
        "func (d *DiffAnalyzer) GetDiff(fromCommit, toCommit string) (string, error) {",
        "\tcmd := exec.Command(\"git\", \"diff\", fromCommit, toCommit)",
        "\toutput, err := cmd.Output()",
        "\tif err != nil {",
        "\t\treturn \"\", fmt.Errorf(\"failed to get git diff: %w\", err)",
        "\t}",
        "\treturn string(output), nil",
        "}",
        "",
        "func (d *DiffAnalyzer) GetCommitAuthor(commit string) (string, error) {",
        "\tcmd := exec.Command(\"git\", \"show\", \"-s\", \"--format=%an\", commit)",
        "\toutput, err := cmd.Output()",
        "\tif err != nil {",
        "\t\treturn \"\", fmt.Errorf(\"failed to get commit author: %w\", err)",
        "\t}",
        "\treturn strings.TrimSpace(string(output)), nil",
        "}",
        "",
        "func (d *DiffAnalyzer) GetLatestCommit() (string, error) {",
        "\tcmd := exec.Command(\"git\", \"rev-parse\", \"HEAD\")",
        "\toutput, err := cmd.Output()",
        "\tif err != nil {",
        "\t\treturn \"\", fmt.Errorf(\"failed to get latest commit: %w\", err)",
        "\t}",
        "\treturn strings.TrimSpace(string(output)), nil",
        "}",
        "",
        "func (d *DiffAnalyzer) GetCommitDiff(commit string) (string, error) {",
        "\tcmd := exec.Command(\"git\", \"show\", commit)",
        "\toutput, err := cmd.Output()",
        "\tif err != nil {",
        "\t\treturn \"\", fmt.Errorf(\"failed to get commit diff: %w\", err)",
        "\t}",
        "\treturn string(output), nil",
        "}",
        "",
        "func (d *DiffAnalyzer) GetCurrentBranch() (string, error) {",
        "\tcmd := exec.Command(\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\")",
        "\toutput, err := cmd.Output()",
        "\tif err != nil {",
        "\t\treturn \"\", fmt.Errorf(\"failed to get current branch: %w\", err)",
        "\t}",
        "\treturn strings.TrimSpace(string(output)), nil",
        "}",
        "",
        "func (d *DiffAnalyzer) IsGitRepository() bool {",
        "\tcmd := exec.Command(\"git\", \"rev-parse\", \"--git-dir\")",
        "\terr := cmd.Run()",
        "\treturn err == nil",
        "}"
      ]
    },
    "internal/storage/json.go": {
      "path": "internal/storage/json.go",
      "lines": [
        "package storage",
        "",
        "import (",
        "\t\"encoding/json\"",
        "\t\"fmt\"",
        "\t\"os\"",
        "\t\"path/filepath\"",
        ")",
        "",
        "type JSONStorage struct {",
        "\tbaseDir string",
        "}",
        "",
        "func NewJSONStorage(baseDir string) *JSONStorage {",
        "\treturn \u0026JSONStorage{",
        "\t\tbaseDir: baseDir,",
        "\t}",
        "}",
        "",
        "func (js *JSONStorage) Save(filename string, data interface{}) error {",
        "\tfilePath := filepath.Join(js.baseDir, filename)",
        "\t",
        "\tdir := filepath.Dir(filePath)",
        "\tif err := os.MkdirAll(dir, 0755); err != nil {",
        "\t\treturn fmt.Errorf(\"failed to create directory: %w\", err)",
        "\t}",
        "",
        "\tjsonData, err := json.MarshalIndent(data, \"\", \"  \")",
        "\tif err != nil {",
        "\t\treturn fmt.Errorf(\"failed to marshal data: %w\", err)",
        "\t}",
        "",
        "\tif err := os.WriteFile(filePath, jsonData, 0644); err != nil {",
        "\t\treturn fmt.Errorf(\"failed to write file: %w\", err)",
        "\t}",
        "",
        "\treturn nil",
        "}",
        "",
        "func (js *JSONStorage) Load(filename string, data interface{}) error {",
        "\tfilePath := filepath.Join(js.baseDir, filename)",
        "\t",
        "\tfileData, err := os.ReadFile(filePath)",
        "\tif err != nil {",
        "\t\treturn fmt.Errorf(\"failed to read file: %w\", err)",
        "\t}",
        "",
        "\tif err := json.Unmarshal(fileData, data); err != nil {",
        "\t\treturn fmt.Errorf(\"failed to unmarshal data: %w\", err)",
        "\t}",
        "",
        "\treturn nil",
        "}",
        "",
        "func (js *JSONStorage) Exists(filename string) bool {",
        "\tfilePath := filepath.Join(js.baseDir, filename)",
        "\t_, err := os.Stat(filePath)",
        "\treturn err == nil",
        "}",
        "",
        "func (js *JSONStorage) Delete(filename string) error {",
        "\tfilePath := filepath.Join(js.baseDir, filename)",
        "\treturn os.Remove(filePath)",
        "}",
        "",
        "func (js *JSONStorage) List(pattern string) ([]string, error) {",
        "\tsearchPattern := filepath.Join(js.baseDir, pattern)",
        "\tmatches, err := filepath.Glob(searchPattern)",
        "\tif err != nil {",
        "\t\treturn nil, fmt.Errorf(\"failed to list files: %w\", err)",
        "\t}",
        "",
        "\tresult := make([]string, len(matches))",
        "\tfor i, match := range matches {",
        "\t\tresult[i], _ = filepath.Rel(js.baseDir, match)",
        "\t}",
        "",
        "\treturn result, nil",
        "}"
      ]
    },
    "internal/storage/metrics.go": {
      "path": "internal/storage/metrics.go",
      "lines": [
        "package storage",
        "",
        "import (",
        "\t\"fmt\"",
        "\t\"time\"",
        "",
        "\t\"github.com/y-hirakawa/ai-code-tracker/internal/tracker\"",
        ")",
        "",
        "type MetricsStorage struct {",
        "\tstorage *JSONStorage",
        "}",
        "",
        "func NewMetricsStorage(baseDir string) *MetricsStorage {",
        "\treturn \u0026MetricsStorage{",
        "\t\tstorage: NewJSONStorage(baseDir),",
        "\t}",
        "}",
        "",
        "func (ms *MetricsStorage) SaveMetrics(result *tracker.AnalysisResult) error {",
        "\tfilename := \"metrics/current.json\"",
        "\treturn ms.storage.Save(filename, result)",
        "}",
        "",
        "func (ms *MetricsStorage) LoadMetrics() (*tracker.AnalysisResult, error) {",
        "\tfilename := \"metrics/current.json\"",
        "\tvar result tracker.AnalysisResult",
        "\t",
        "\tif !ms.storage.Exists(filename) {",
        "\t\treturn \u0026tracker.AnalysisResult{",
        "\t\t\tTotalLines:  0,",
        "\t\t\tAILines:     0,",
        "\t\t\tHumanLines:  0,",
        "\t\t\tPercentage:  0,",
        "\t\t\tLastUpdated: time.Now(),",
        "\t\t}, nil",
        "\t}",
        "\t",
        "\tif err := ms.storage.Load(filename, \u0026result); err != nil {",
        "\t\treturn nil, fmt.Errorf(\"failed to load metrics: %w\", err)",
        "\t}",
        "\t",
        "\treturn \u0026result, nil",
        "}",
        "",
        "func (ms *MetricsStorage) SaveConfig(config *tracker.Config) error {",
        "\tfilename := \"config.json\"",
        "\treturn ms.storage.Save(filename, config)",
        "}",
        "",
        "func (ms *MetricsStorage) LoadConfig() (*tracker.Config, error) {",
        "\tfilename := \"config.json\"",
        "\tvar config tracker.Config",
        "\t",
        "\tif !ms.storage.Exists(filename) {",
        "\t\treturn ms.getDefaultConfig(), nil",
        "\t}",
        "\t",
        "\tif err := ms.storage.Load(filename, \u0026config); err != nil {",
        "\t\treturn nil, fmt.Errorf(\"failed to load config: %w\", err)",
        "\t}",
        "\t",
        "\treturn \u0026config, nil",
        "}",
        "",
        "func (ms *MetricsStorage) getDefaultConfig() *tracker.Config {",
        "\treturn \u0026tracker.Config{",
        "\t\tTargetAIPercentage: 80.0,",
        "\t\tTrackedExtensions:  []string{\".go\", \".py\", \".js\", \".ts\", \".java\", \".cpp\", \".c\", \".h\", \".rs\"},",
        "\t\tExcludePatterns:    []string{\"*_test.go\", \"*.test.js\", \"*.spec.ts\", \"*_generated.go\"},",
        "\t\tAuthorMappings:     make(map[string]string),",
        "\t}",
        "}",
        "",
        "func (ms *MetricsStorage) ArchiveMetrics(result *tracker.AnalysisResult) error {",
        "\ttimestamp := result.LastUpdated.Format(\"20060102_150405\")",
        "\tfilename := fmt.Sprintf(\"metrics/archive/%s.json\", timestamp)",
        "\treturn ms.storage.Save(filename, result)",
        "}"
      ]
    },
    "internal/tracker/analyzer.go": {
      "path": "internal/tracker/analyzer.go",
      "lines": [
        "package tracker",
        "",
        "import (",
        "\t\"fmt\"",
        "\t\"strings\"",
        ")",
        "",
        "type Analyzer struct {",
        "\tconfig *Config",
        "}",
        "",
        "func NewAnalyzer(config *Config) *Analyzer {",
        "\treturn \u0026Analyzer{",
        "\t\tconfig: config,",
        "\t}",
        "}",
        "",
        "func (a *Analyzer) AnalyzeCheckpoints(before, after *Checkpoint) (*AnalysisResult, error) {",
        "\tresult := \u0026AnalysisResult{",
        "\t\tLastUpdated: after.Timestamp,",
        "\t}",
        "",
        "\tisAIAuthor := a.IsAIAuthor(after.Author)",
        "",
        "\tfor path, afterFile := range after.Files {",
        "\t\tbeforeFile, exists := before.Files[path]",
        "\t\tif !exists {",
        "\t\t\t// New file",
        "\t\t\tif isAIAuthor {",
        "\t\t\t\tresult.AILines += len(afterFile.Lines)",
        "\t\t\t} else {",
        "\t\t\t\tresult.HumanLines += len(afterFile.Lines)",
        "\t\t\t}",
        "\t\t\tresult.TotalLines += len(afterFile.Lines)",
        "\t\t\tcontinue",
        "\t\t}",
        "",
        "\t\t// Modified file - count added lines",
        "\t\tstats := a.compareFiles(beforeFile, afterFile, isAIAuthor)",
        "\t\tresult.AILines += stats.AILines",
        "\t\tresult.HumanLines += stats.HumanLines",
        "\t\t// Don't add total lines here - we only want the diff",
        "\t}",
        "",
        "\tfor path, beforeFile := range before.Files {",
        "\t\tif _, exists := after.Files[path]; !exists {",
        "\t\t\tresult.TotalLines -= len(beforeFile.Lines)",
        "\t\t}",
        "\t}",
        "",
        "\tif result.TotalLines \u003e 0 {",
        "\t\tresult.Percentage = float64(result.AILines) / float64(result.TotalLines) * 100",
        "\t}",
        "",
        "\treturn result, nil",
        "}",
        "",
        "func (a *Analyzer) AnalyzeFromGitDiff(diff string, currentMetrics *AnalysisResult) (*AnalysisResult, error) {",
        "\tlines := strings.Split(diff, \"\\n\")",
        "\tnewAILines := 0",
        "\tnewHumanLines := 0",
        "",
        "\tisAICommit := false",
        "\tfor _, line := range lines {",
        "\t\tif strings.HasPrefix(line, \"Author:\") {",
        "\t\t\tauthor := strings.TrimSpace(strings.TrimPrefix(line, \"Author:\"))",
        "\t\t\tisAICommit = a.IsAIAuthor(author)",
        "\t\t}",
        "",
        "\t\tif strings.HasPrefix(line, \"+\") \u0026\u0026 !strings.HasPrefix(line, \"+++\") {",
        "\t\t\tif isAICommit {",
        "\t\t\t\tnewAILines++",
        "\t\t\t} else {",
        "\t\t\t\tnewHumanLines++",
        "\t\t\t}",
        "\t\t}",
        "\t}",
        "",
        "\tresult := \u0026AnalysisResult{",
        "\t\tTotalLines:  currentMetrics.TotalLines + newAILines + newHumanLines,",
        "\t\tAILines:     currentMetrics.AILines + newAILines,",
        "\t\tHumanLines:  currentMetrics.HumanLines + newHumanLines,",
        "\t\tLastUpdated: currentMetrics.LastUpdated,",
        "\t}",
        "",
        "\tif result.TotalLines \u003e 0 {",
        "\t\tresult.Percentage = float64(result.AILines) / float64(result.TotalLines) * 100",
        "\t}",
        "",
        "\treturn result, nil",
        "}",
        "",
        "func (a *Analyzer) GetFileStats(checkpoint *Checkpoint) []FileStats {",
        "\tstats := make([]FileStats, 0, len(checkpoint.Files))",
        "\t",
        "\tfor path, file := range checkpoint.Files {",
        "\t\tstat := FileStats{",
        "\t\t\tPath:       path,",
        "\t\t\tTotalLines: len(file.Lines),",
        "\t\t}",
        "\t\t",
        "\t\tif a.IsAIAuthor(checkpoint.Author) {",
        "\t\t\tstat.AILines = len(file.Lines)",
        "\t\t} else {",
        "\t\t\tstat.HumanLines = len(file.Lines)",
        "\t\t}",
        "\t\t",
        "\t\tstats = append(stats, stat)",
        "\t}",
        "\t",
        "\treturn stats",
        "}",
        "",
        "func (a *Analyzer) compareFiles(before, after FileContent, isAIAuthor bool) FileStats {",
        "\tstats := FileStats{",
        "\t\tPath: after.Path,",
        "\t}",
        "",
        "\t// For now, just count the difference in total lines",
        "\t// This is a simplified approach that assumes lines are only added, not modified",
        "\tlineDiff := len(after.Lines) - len(before.Lines)",
        "\t",
        "\tif lineDiff \u003e 0 {",
        "\t\tif isAIAuthor {",
        "\t\t\tstats.AILines = lineDiff",
        "\t\t} else {",
        "\t\t\tstats.HumanLines = lineDiff",
        "\t\t}",
        "\t}",
        "",
        "\treturn stats",
        "}",
        "",
        "func (a *Analyzer) IsAIAuthor(author string) bool {",
        "\taiAuthors := []string{\"claude\", \"ai\", \"assistant\", \"bot\"}",
        "\tauthorLower := strings.ToLower(author)",
        "\t",
        "\tif mapping, exists := a.config.AuthorMappings[author]; exists {",
        "\t\tauthorLower = strings.ToLower(mapping)",
        "\t}",
        "\t",
        "\tfor _, aiAuthor := range aiAuthors {",
        "\t\tif strings.Contains(authorLower, aiAuthor) {",
        "\t\t\treturn true",
        "\t\t}",
        "\t}",
        "\t",
        "\treturn false",
        "}",
        "",
        "func (a *Analyzer) GenerateReport(result *AnalysisResult) string {",
        "\tprogress := result.Percentage / a.config.TargetAIPercentage * 100",
        "\tif progress \u003e 100 {",
        "\t\tprogress = 100",
        "\t}",
        "",
        "\treport := fmt.Sprintf(`AI Code Tracking Report",
        "======================",
        "Total Lines: %d",
        "AI Lines: %d (%.1f%%)",
        "Human Lines: %d (%.1f%%)",
        "",
        "Target: %.1f%% AI code",
        "Progress: %.1f%%",
        "",
        "Last Updated: %s",
        "`,",
        "\t\tresult.TotalLines,",
        "\t\tresult.AILines, result.Percentage,",
        "\t\tresult.HumanLines, 100-result.Percentage,",
        "\t\ta.config.TargetAIPercentage,",
        "\t\tprogress,",
        "\t\tresult.LastUpdated.Format(\"2006-01-02 15:04:05\"))",
        "",
        "\treturn report",
        "}"
      ]
    },
    "internal/tracker/checkpoint.go": {
      "path": "internal/tracker/checkpoint.go",
      "lines": [
        "package tracker",
        "",
        "import (",
        "\t\"crypto/md5\"",
        "\t\"encoding/json\"",
        "\t\"fmt\"",
        "\t\"io\"",
        "\t\"os\"",
        "\t\"path/filepath\"",
        "\t\"strings\"",
        "\t\"time\"",
        ")",
        "",
        "type CheckpointManager struct {",
        "\tbaseDir string",
        "}",
        "",
        "func NewCheckpointManager(baseDir string) *CheckpointManager {",
        "\treturn \u0026CheckpointManager{",
        "\t\tbaseDir: baseDir,",
        "\t}",
        "}",
        "",
        "func (cm *CheckpointManager) CreateCheckpoint(author string, extensions []string) (*Checkpoint, error) {",
        "\tcheckpoint := \u0026Checkpoint{",
        "\t\tID:        cm.generateID(),",
        "\t\tTimestamp: time.Now(),",
        "\t\tAuthor:    author,",
        "\t\tFiles:     make(map[string]FileContent),",
        "\t}",
        "",
        "\terr := cm.scanCodeFiles(\".\", extensions, checkpoint)",
        "\tif err != nil {",
        "\t\treturn nil, fmt.Errorf(\"failed to scan code files: %w\", err)",
        "\t}",
        "",
        "\treturn checkpoint, nil",
        "}",
        "",
        "func (cm *CheckpointManager) SaveCheckpoint(checkpoint *Checkpoint) error {",
        "\tcheckpointDir := filepath.Join(cm.baseDir, \"checkpoints\")",
        "\tif err := os.MkdirAll(checkpointDir, 0755); err != nil {",
        "\t\treturn fmt.Errorf(\"failed to create checkpoint directory: %w\", err)",
        "\t}",
        "",
        "\tfilename := filepath.Join(checkpointDir, fmt.Sprintf(\"%s_%s.json\", checkpoint.Author, checkpoint.ID))",
        "\tdata, err := json.MarshalIndent(checkpoint, \"\", \"  \")",
        "\tif err != nil {",
        "\t\treturn fmt.Errorf(\"failed to marshal checkpoint: %w\", err)",
        "\t}",
        "",
        "\tif err := os.WriteFile(filename, data, 0644); err != nil {",
        "\t\treturn fmt.Errorf(\"failed to write checkpoint file: %w\", err)",
        "\t}",
        "",
        "\treturn nil",
        "}",
        "",
        "func (cm *CheckpointManager) LoadCheckpoint(filename string) (*Checkpoint, error) {",
        "\tdata, err := os.ReadFile(filename)",
        "\tif err != nil {",
        "\t\treturn nil, fmt.Errorf(\"failed to read checkpoint file: %w\", err)",
        "\t}",
        "",
        "\tvar checkpoint Checkpoint",
        "\tif err := json.Unmarshal(data, \u0026checkpoint); err != nil {",
        "\t\treturn nil, fmt.Errorf(\"failed to unmarshal checkpoint: %w\", err)",
        "\t}",
        "",
        "\treturn \u0026checkpoint, nil",
        "}",
        "",
        "func (cm *CheckpointManager) GetLatestCheckpoints(author string, count int) ([]*Checkpoint, error) {",
        "\tcheckpointDir := filepath.Join(cm.baseDir, \"checkpoints\")",
        "\tvar pattern string",
        "\tif author == \"*\" {",
        "\t\tpattern = filepath.Join(checkpointDir, \"*.json\")",
        "\t} else {",
        "\t\tpattern = filepath.Join(checkpointDir, fmt.Sprintf(\"%s_*.json\", author))",
        "\t}",
        "\t",
        "\tfiles, err := filepath.Glob(pattern)",
        "\tif err != nil {",
        "\t\treturn nil, fmt.Errorf(\"failed to list checkpoints: %w\", err)",
        "\t}",
        "",
        "\tcheckpoints := make([]*Checkpoint, 0, len(files))",
        "\tfor _, file := range files {",
        "\t\tcp, err := cm.LoadCheckpoint(file)",
        "\t\tif err != nil {",
        "\t\t\tcontinue",
        "\t\t}",
        "\t\tcheckpoints = append(checkpoints, cp)",
        "\t}",
        "",
        "\tif len(checkpoints) \u003e count \u0026\u0026 count \u003e 0 {",
        "\t\tcheckpoints = checkpoints[len(checkpoints)-count:]",
        "\t}",
        "",
        "\treturn checkpoints, nil",
        "}",
        "",
        "func (cm *CheckpointManager) scanCodeFiles(root string, extensions []string, checkpoint *Checkpoint) error {",
        "\textMap := make(map[string]bool)",
        "\tfor _, ext := range extensions {",
        "\t\textMap[ext] = true",
        "\t}",
        "",
        "\treturn filepath.Walk(root, func(path string, info os.FileInfo, err error) error {",
        "\t\tif err != nil {",
        "\t\t\treturn err",
        "\t\t}",
        "",
        "\t\tif info.IsDir() || strings.HasPrefix(path, \".ai_tracking\") || strings.HasPrefix(path, \".git\") {",
        "\t\t\treturn nil",
        "\t\t}",
        "",
        "\t\text := filepath.Ext(path)",
        "\t\tif !extMap[ext] {",
        "\t\t\treturn nil",
        "\t\t}",
        "",
        "\t\tcontent, err := cm.readFileLines(path)",
        "\t\tif err != nil {",
        "\t\t\treturn err",
        "\t\t}",
        "",
        "\t\tcheckpoint.Files[path] = FileContent{",
        "\t\t\tPath:  path,",
        "\t\t\tLines: content,",
        "\t\t}",
        "",
        "\t\treturn nil",
        "\t})",
        "}",
        "",
        "func (cm *CheckpointManager) readFileLines(path string) ([]string, error) {",
        "\tdata, err := os.ReadFile(path)",
        "\tif err != nil {",
        "\t\treturn nil, err",
        "\t}",
        "",
        "\tlines := strings.Split(string(data), \"\\n\")",
        "\treturn lines, nil",
        "}",
        "",
        "func (cm *CheckpointManager) generateID() string {",
        "\th := md5.New()",
        "\tio.WriteString(h, time.Now().String())",
        "\treturn fmt.Sprintf(\"%x\", h.Sum(nil))[:8]",
        "}"
      ]
    },
    "internal/tracker/types.go": {
      "path": "internal/tracker/types.go",
      "lines": [
        "package tracker",
        "",
        "import \"time\"",
        "",
        "type Checkpoint struct {",
        "\tID        string                 `json:\"id\"`",
        "\tTimestamp time.Time              `json:\"timestamp\"`",
        "\tAuthor    string                 `json:\"author\"`",
        "\tFiles     map[string]FileContent `json:\"files\"`",
        "}",
        "",
        "type FileContent struct {",
        "\tPath  string   `json:\"path\"`",
        "\tLines []string `json:\"lines\"`",
        "}",
        "",
        "type AnalysisResult struct {",
        "\tTotalLines  int     `json:\"total_lines\"`",
        "\tAILines     int     `json:\"ai_lines\"`",
        "\tHumanLines  int     `json:\"human_lines\"`",
        "\tPercentage  float64 `json:\"percentage\"`",
        "\tLastUpdated time.Time `json:\"last_updated\"`",
        "}",
        "",
        "type FileStats struct {",
        "\tPath       string `json:\"path\"`",
        "\tTotalLines int    `json:\"total_lines\"`",
        "\tAILines    int    `json:\"ai_lines\"`",
        "\tHumanLines int    `json:\"human_lines\"`",
        "}",
        "",
        "type Config struct {",
        "\tTargetAIPercentage float64  `json:\"target_ai_percentage\"`",
        "\tTrackedExtensions  []string `json:\"tracked_extensions\"`",
        "\tExcludePatterns    []string `json:\"exclude_patterns\"`",
        "\tAuthorMappings     map[string]string `json:\"author_mappings\"`",
        "}"
      ]
    },
    "test/example.swift": {
      "path": "test/example.swift",
      "lines": [
        "import Foundation",
        "",
        "// Simple vocabulary learning app",
        "struct VocabularyCard {",
        "    let word: String",
        "    let translation: String",
        "}",
        "",
        "let cards = [",
        "    VocabularyCard(word: \"Hello\", translation: \"こんにちは\"),",
        "    VocabularyCard(word: \"Thank you\", translation: \"ありがとう\")",
        "]",
        "",
        "print(\"Learning \\(cards.count) words\")"
      ]
    }
  }
}